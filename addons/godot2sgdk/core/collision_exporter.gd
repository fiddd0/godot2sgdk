@tool
extends RefCounted
class_name CollisionExporter

const COLLISION_TYPES = {
	"RECTANGLE": 0,
	"CIRCLE": 1, 
	"POLYGON": 2,
	"TILE": 3
}

class CollisionData:
	var type: int
	var position: Vector2
	var size: Vector2
	var radius: float
	var points: PackedVector2Array
	var is_trigger: bool
	var physics_layer: int
	var node_name: String  # ‚úÖ ADICIONAR propriedade para armazenar o nome

func export_collision_in_scene(scene_root: Node) -> Dictionary:
	var collision_data = {}
	var collision_nodes = _find_collision_nodes(scene_root)
	
	for node in collision_nodes:
		var data = _extract_collision_data(node)
		if data:
			collision_data[node.name] = data
			var header_content = _generate_collision_header(data, node.name)
			_save_collision_header(node.name, header_content)
	
	return collision_data

func _find_collision_nodes(node: Node) -> Array:
	var nodes = []
	
	if not node:
		return nodes
		
	# ‚úÖ DETECTAR N√ìS DE COLIS√ÉO DIRETOS
	if (node is CollisionShape2D or node is CollisionPolygon2D):
		nodes.append(node)
		
	# ‚úÖ DETECTAR Area2D E SEUS FILHOS DE COLIS√ÉO
	elif node is Area2D:
		nodes.append(node)  # Adiciona a Area2D itself
		# ‚úÖ PROCURAR POR FILHOS DE COLIS√ÉO DENTRO DA Area2D
		for child in node.get_children():
			if child is CollisionShape2D or child is CollisionPolygon2D:
				nodes.append(child)
		
	# ‚úÖ DETECTAR n√≥s de f√≠sica que podem ter colis√£o
	elif (node is CharacterBody2D or node is RigidBody2D):
		for child in node.get_children():
			if child is CollisionShape2D or child is CollisionPolygon2D:
				nodes.append(child)
	
	# ‚úÖ VERIFICAR FILHOS RECURSIVAMENTE (excluindo Area2D j√° processada)
	for child in node.get_children():
		# N√£o processar Area2D novamente (j√° processamos acima)
		nodes.append_array(_find_collision_nodes(child))
	
	return nodes

func _extract_collision_data(node: Node) -> CollisionData:
	var data = CollisionData.new()
	data.node_name = node.name  # ‚úÖ ARMAZENAR o nome do node
	
	if node is CollisionShape2D:
		var shape = node.shape
		if shape is RectangleShape2D:
			data.type = COLLISION_TYPES.RECTANGLE
			data.size = shape.size
			data.position = node.position
		elif shape is CircleShape2D:
			data.type = COLLISION_TYPES.CIRCLE
			data.radius = shape.radius
			data.position = node.position
		# Adicionar mais tipos de shapes...
	elif node is CollisionPolygon2D:
		data.type = COLLISION_TYPES.POLYGON
		data.points = node.polygon
		data.position = node.position
		data.is_trigger = false
		
		if node.get_parent() and node.get_parent().has_method("get_collision_layer"):
			data.physics_layer = node.get_parent().collision_layer
		else:
			data.physics_layer = 1
				
	elif node is Area2D:
		print("üü¶ Processing Area2D: ", node.name)
		data.type = COLLISION_TYPES.RECTANGLE # ‚Üê Pode estar for√ßando ret√¢ngulo
		data.is_trigger = true
		data.position = node.position
		data.physics_layer = node.collision_layer
		
		# ‚úÖ TENTAR ENCONTRAR SHAPE FILHO PARA OBTER TAMANHO/FORMA
		for child in node.get_children():
			print("   üîç Checking child: ", child.name, " Type: ", child.get_class())
			if child is CollisionShape2D:
				var shape_data = _extract_collision_data(child)
				data.type = shape_data.type  # ‚úÖ HERDAR O TIPO!
				data.size = shape_data.size # ‚Üê Para ret√¢ngulo
				data.radius = shape_data.radius # ‚Üê Para c√≠rculos
				print("   ‚úÖ Found CollisionShape2D - Size: ", data.size, " Radius: ", data.radius)
				break
			elif child is CollisionPolygon2D:
				var poly_data = _extract_collision_data(child)
				data.points = poly_data.points # ‚Üê Para pol√≠gonos
				data.type = COLLISION_TYPES.POLYGON # ‚Üê IMPORTANTE!
				print("   ‚úÖ Found CollisionPolygon2D - Points: ", data.points.size())
				break
	
	return data

func _generate_collision_header(collision_data: CollisionData, node_name: String) -> String:  # ‚úÖ RECEBER nome como par√¢metro
	print("Generating header for: ", node_name, " Type: ", collision_data.type)	
	
	var header = "// Collision: %s\n" % node_name  # ‚úÖ USAR o nome passado
	header += "// Generated by Godot2SGDK\n\n"
	
	match collision_data.type:
		COLLISION_TYPES.RECTANGLE:
			header += "const CollisionRect %s = {%d, %d, %d, %d, %d};\n" % [
				node_name.to_lower(),  # ‚úÖ USAR node_name
				collision_data.position.x,
				collision_data.position.y,
				collision_data.size.x,
				collision_data.size.y,
				int(collision_data.is_trigger)
			]
		COLLISION_TYPES.CIRCLE:
			header += "const CollisionCircle %s = {%d, %d, %d, %d};\n" % [
				node_name.to_lower(),  # ‚úÖ USAR node_name
				collision_data.position.x,
				collision_data.position.y,
				collision_data.radius,
				int(collision_data.is_trigger)
			]
		COLLISION_TYPES.POLYGON:
					header += "// Polygon with %d points\n" % collision_data.points.size()
					header += "const CollisionPolygon %s = {\n" % node_name.to_lower()
					header += "    %d,  // point_count\n" % collision_data.points.size()
					header += "    (Vector2[]){"
					
					# Adicionar todos os pontos do pol√≠gono
					for i in range(collision_data.points.size()):
						if i > 0:
							header += ", "
						header += "{%d, %d}" % [collision_data.points[i].x, collision_data.points[i].y]
					
					header += "},  // points\n"
					header += "    {%d, %d},  // position\n" % [collision_data.position.x, collision_data.position.y]
					header += "    %d  // is_trigger\n" % int(collision_data.is_trigger)
					header += "};\n"
	
	return header

func _save_collision_header(node_name: String, content: String) -> void:
	var file_path = "res://export/%s_collision.h" % node_name.to_lower()
	var file = FileAccess.open(file_path, FileAccess.WRITE)
	if file:
		file.store_string(content)
		file.close()
		print("‚úÖ Collision header saved: ", file_path)
	else:
		push_error("‚ùå Failed to save collision header: ", file_path)
