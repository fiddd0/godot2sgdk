@tool
extends RefCounted

class_name SpriteExporter
# LINHA 5: Adicionar após class_name
var palette_manager: PaletteManager

# Classes de dados para organização
class SpriteData:
	var name: String
	var texture: Texture2D
	var region: Rect2
	var frame_coords: Vector2
	var hframes: int = 1
	var vframes: int = 1
	var animations: Dictionary = {}
	var is_animated: bool = false

class AnimationData:
	var name: String
	var frames: Array = []
	var speed: float = 5.0
	var loop: bool = true

# LINHA 10: Adicionar no início do arquivo (após as classes)
func _init():
	palette_manager = PaletteManager.new()	

# Constantes para limites do Mega Drive
const MAX_SPRITES_PER_LINE: int = 20
const MAX_SPRITE_SIZE: Vector2 = Vector2(32, 32)

# Exporta todos os sprites na cena
func export_sprites_in_scene(scene_root: Node, export_path: String) -> Dictionary:
	var result := {
		"success": false,
		"message": "",
		"exported_files": []
	}
	
	if not scene_root:
		result.message = "Cena raiz não fornecida"
		return result
	
	var sprites := _find_sprites_in_node(scene_root)
	
	if sprites.is_empty():
		result.message = "Nenhum sprite encontrado na cena"
		return result
	
	# Criar diretório de exportação se não existir - CORRIGIDO
	var dir := DirAccess.open(export_path.get_base_dir())
	if not dir:
		DirAccess.make_dir_recursive_absolute(export_path.get_base_dir())
	
	var header_content := "// Sprite data exported from Godot\n// Generated by Godot2SGDK plugin\n\n"
	var sprite_index := 0
	
	for sprite_data in sprites:
		var sprite_header := _export_sprite_data(sprite_data, export_path, sprite_index)
		if not sprite_header.is_empty():
			header_content += sprite_header + "\n"
			result.exported_files.append(sprite_data.name + "_sprite.h")
		sprite_index += 1
	
	# Salvar arquivo header principal
	var header_file := FileAccess.open(export_path, FileAccess.WRITE)
	if header_file:
		header_file.store_string(header_content)
		header_file.close()
		result.success = true
		result.message = "Exportação concluída: %d sprites exportados" % sprites.size()
	else:
		result.message = "Erro ao salvar arquivo header: " + export_path
	
	return result

# Encontrar todos os sprites na cena
func _find_sprites_in_node(node: Node) -> Array:
	var sprites := []
	
	# Verificar se o nó atual é um sprite
	if node is Sprite2D or node is AnimatedSprite2D:
		var sprite_data := _extract_sprite_data(node)
		if sprite_data:
			sprites.append(sprite_data)
	
	# Recursivamente verificar os filhos
	for child in node.get_children():
		sprites.append_array(_find_sprites_in_node(child))
	
	return sprites

# Extrair dados do sprite
func _extract_sprite_data(sprite_node: Node) -> SpriteData:
	var sprite_data := SpriteData.new()
	sprite_data.name = sprite_node.name
	
	if sprite_node is Sprite2D:
		sprite_data.texture = sprite_node.texture
		sprite_data.region = Rect2(0, 0, sprite_data.texture.get_width(), sprite_data.texture.get_height()) if sprite_data.texture else Rect2()
		
	elif sprite_node is AnimatedSprite2D:
		sprite_data.is_animated = true
		if sprite_node.sprite_frames and sprite_node.sprite_frames.get_frame_count("default") > 0:
			sprite_data.texture = sprite_node.sprite_frames.get_frame_texture("default", 0)
			sprite_data.region = Rect2(0, 0, sprite_data.texture.get_width(), sprite_data.texture.get_height())
			_extract_animations(sprite_node, sprite_data)
	
	return sprite_data

# Extrair dados de animação
func _extract_animations(animated_sprite: AnimatedSprite2D, sprite_data: SpriteData) -> void:
	if not animated_sprite.sprite_frames:
		return
	
	var sprite_frames := animated_sprite.sprite_frames
	
	for anim_name in sprite_frames.get_animation_names():
		var anim_data := AnimationData.new()
		anim_data.name = anim_name
		anim_data.speed = sprite_frames.get_animation_speed(anim_name)
		anim_data.loop = sprite_frames.get_animation_loop(anim_name)
		
		for frame_idx in sprite_frames.get_frame_count(anim_name):
			anim_data.frames.append({
				"texture": sprite_frames.get_frame_texture(anim_name, frame_idx),
				"duration": sprite_frames.get_frame_duration(anim_name, frame_idx)
			})
		
		sprite_data.animations[anim_name] = anim_data

# Exportar dados do sprite e gerar header
func _export_sprite_data(sprite_data: SpriteData, export_path: String, index: int) -> String:
	if not sprite_data.texture:
		return ""
	
	var texture := sprite_data.texture
	var image := texture.get_image()
	
	if texture.get_width() > MAX_SPRITE_SIZE.x or texture.get_height() > MAX_SPRITE_SIZE.y:
		push_warning("Sprite '%s' excede tamanho máximo suportado (%dx%d)" % [
			sprite_data.name, MAX_SPRITE_SIZE.x, MAX_SPRITE_SIZE.y])
		return ""
	
	var base_name := sprite_data.name.to_snake_case()
	var header_filename := "%s_sprite.h" % base_name
	var header_path := export_path.get_base_dir() + "/" + header_filename
	
	var header_content := "// Sprite: %s\n" % sprite_data.name
	header_content += "// Size: %dx%d\n\n" % [texture.get_width(), texture.get_height()]
	header_content += _generate_sprite_data(image, base_name)
	
	if sprite_data.is_animated and not sprite_data.animations.is_empty():
		header_content += _generate_animation_data(sprite_data, base_name)
	
	var file := FileAccess.open(header_path, FileAccess.WRITE)
	if file:
		file.store_string(header_content)
		file.close()
		return '#include "%s"\n' % header_filename
	
	return ""

# Gerar dados do sprite no formato SGDK
func _generate_sprite_data(image: Image, base_name: String) -> String:
	var result := "const unsigned short %s_data[] = {\n" % base_name
	var width := image.get_width()
	var height := image.get_height()
	
	for y in range(height):
		result += "    "
		for x in range(width):
			var color := image.get_pixel(x, y)
			var color_index := _color_to_md_index(color)
			result += "0x%02X, " % color_index
		
		result += "// Linha %d\n" % y
	
	result += "};\n\n"
	
	result += "const SpriteDefinition %s_def = {\n" % base_name
	result += "    %d, // width\n" % width
	result += "    %d, // height\n" % height
	result += "    %s_data // sprite data\n" % base_name
	result += "};\n\n"
	
	return result

# Gerar dados de animação
func _generate_animation_data(sprite_data: SpriteData, base_name: String) -> String:
	var result := "// Animation data for %s\n" % sprite_data.name
	
	for anim_name in sprite_data.animations:
		var anim_data: AnimationData = sprite_data.animations[anim_name]
		var anim_var_name := "%s_%s_anim" % [base_name, anim_name.to_snake_case()]
		
		result += "const AnimationFrame %s_frames[] = {\n" % anim_var_name
		for frame in anim_data.frames:
			result += "    { 0, %d }, // frame duration\n" % int(frame.duration * 60)
		
		result += "};\n\n"
		
		result += "const Animation %s = {\n" % anim_var_name
		result += "    %d, // frame count\n" % anim_data.frames.size()
		result += "    %s_frames, // frames\n" % anim_var_name
		result += "    %s, // loop\n" % ("TRUE" if anim_data.loop else "FALSE")
		result += "    %d // speed\n" % int(anim_data.speed)
		result += "};\n\n"
	
	return result

# LINHA 250: Substituir a função _color_to_md_index
func _color_to_md_index(color: Color) -> int:
	# Usar o palette_manager para conversão precisa
	return palette_manager.color_to_palette_index(color)
