@tool
extends RefCounted

class_name SpriteExporter

# Classes de dados para organização
class SpriteData:
	var name: String
	var texture: Texture2D
	var region: Rect2
	var frame_coords: Vector2
	var hframes: int = 1
	var vframes: int = 1
	var animations: Dictionary = {}
	var is_animated: bool = false

class AnimationData:
	var name: String
	var frames: Array = []
	var speed: float = 5.0
	var loop: bool = true

# Constantes para limites do Mega Drive
const MAX_SPRITES_PER_LINE: int = 20
const MAX_SPRITE_SIZE: Vector2 = Vector2(32, 32)

# Variável para gerenciamento de paleta
var palette_manager

func _init():
	# Carregar palette_manager se disponível
	var palette_script = load("res://addons/godot2sgdk/core/palette_manager.gd")
	if palette_script:
		palette_manager = palette_script.new()
	else:
		push_warning("PaletteManager not found, using fallback color conversion")

# Exporta todos os sprites na cena
func export_sprites_in_scene(scene_root: Node, export_path: String) -> Dictionary:
	var result = {"success": false, "message": "", "sprite_count": 0}
		
	# ✅ CORREÇÃO: Garantir que export_path seja um diretório
	
	var export_dir = export_path
	if export_path.get_extension() == "h":
		export_dir = export_path.get_base_dir()
		push_warning("Export path was a file, using directory: " + export_dir)
	
	# ✅ CORREÇÃO: Usar _find_sprite_nodes (encontra Nodes, não SpriteData)
	var sprite_nodes = _find_sprite_nodes(scene_root)
	if sprite_nodes.is_empty():
		result["message"] = "No sprites found in scene"
		return result
	
	# ✅ CRIAR ARQUIVO PRINCIPAL APENAS UMA VEZ
	var main_header = "// Sprite data exported from Godot\n"
	main_header += "// Generated by Godot2SGDK plugin\n\n"
	
	var exported_count = 0
	var processed_sprites = {}  # ✅ DICIONÁRIO PARA EVITAR DUPLICATAS
	
	for sprite_node in sprite_nodes:
		# ✅ CORREÇÃO: Extrair SpriteData do node
		var sprite_data = _extract_sprite_data(sprite_node)
		if sprite_data and sprite_data.texture:
			if processed_sprites.has(sprite_data.name):
				continue
			processed_sprites[sprite_data.name] = true			
			# ✅ CORREÇÃO: Chamar a função correta que espera SpriteData
			var include_line = _export_sprite_data_to_file(sprite_data, export_dir, exported_count)
			if include_line and not include_line.is_empty():
				main_header += include_line
				exported_count += 1
	
	# ✅ SALVAR ARQUIVO PRINCIPAL
	var main_file_path = export_dir + "/sprites.h"
	if _save_to_file(main_file_path, main_header):
		result["success"] = true
		result["message"] = "Exported %d sprites" % exported_count
		result["sprite_count"] = exported_count
	else:
		result["message"] = "Failed to save main sprites header"
	
	return result

# ✅ CORREÇÃO: Encontrar nodes de sprite (não dados)
func _find_sprite_nodes(node: Node) -> Array:
	var nodes := []
	
	# Verificar se o nó atual é um sprite
	if node is Sprite2D or node is AnimatedSprite2D:
		nodes.append(node)
	
	# Recursivamente verificar os filhos
	for child in node.get_children():
		nodes.append_array(_find_sprite_nodes(child))
	
	return nodes

# ✅ CORREÇÃO: Função renomeada para evitar conflito
func _export_sprite_data_to_file(sprite_data: SpriteData, export_path: String, index: int) -> String:
	if not sprite_data.texture:
		return ""
	
	var texture := sprite_data.texture
	
	# Verificar tamanho máximo
	if texture.get_width() > MAX_SPRITE_SIZE.x or texture.get_height() > MAX_SPRITE_SIZE.y:
		push_warning("Sprite '%s' excede tamanho máximo suportado (%dx%d)" % [
			sprite_data.name, MAX_SPRITE_SIZE.x, MAX_SPRITE_SIZE.y])
		return ""
	
	var base_name := sprite_data.name.to_snake_case()
	var header_filename := "%s_sprite.h" % base_name
	var export_dir = export_path
	if export_path.get_extension() == "h":
		export_dir = export_path.get_base_dir()
	
	var header_path := export_path + "/" + header_filename
	
	# Converter texture para image
	var image = _convert_texture_to_image(texture)
	if not image:
		return ""
	
	var header_content := "// Sprite: %s\n" % sprite_data.name
	header_content += "// Size: %dx%d\n\n" % [texture.get_width(), texture.get_height()]
	header_content += _generate_sprite_data(image, base_name)
	
	# ✅ CORREÇÃO: Verificar se é animado e tem animações
	if sprite_data.is_animated and not sprite_data.animations.is_empty():
		header_content += _generate_animation_data(sprite_data, base_name)
	
	if _save_to_file(header_path, header_content):
		return '#include "%s"\n' % header_filename
	
	return ""

# Extrair dados do sprite (converte Node para SpriteData)
func _extract_sprite_data(sprite_node: Node) -> SpriteData:
	var sprite_data := SpriteData.new()
	sprite_data.name = sprite_node.name
	
	if sprite_node is Sprite2D:
		sprite_data.texture = sprite_node.texture
		if sprite_data.texture:
			sprite_data.region = Rect2(0, 0, sprite_data.texture.get_width(), sprite_data.texture.get_height())
		
	elif sprite_node is AnimatedSprite2D:
		sprite_data.is_animated = true
		if sprite_node.sprite_frames and sprite_node.sprite_frames.get_frame_count("default") > 0:
			sprite_data.texture = sprite_node.sprite_frames.get_frame_texture("default", 0)
			if sprite_data.texture:
				sprite_data.region = Rect2(0, 0, sprite_data.texture.get_width(), sprite_data.texture.get_height())
			_extract_animations(sprite_node, sprite_data)
	
	return sprite_data

# Extrair dados de animação
func _extract_animations(animated_sprite: AnimatedSprite2D, sprite_data: SpriteData) -> void:
	if not animated_sprite.sprite_frames:
		return
	
	var sprite_frames := animated_sprite.sprite_frames
	
	for anim_name in sprite_frames.get_animation_names():
		var anim_data := AnimationData.new()
		anim_data.name = anim_name
		anim_data.speed = sprite_frames.get_animation_speed(anim_name)
		anim_data.loop = sprite_frames.get_animation_loop(anim_name)
		
		for frame_idx in sprite_frames.get_frame_count(anim_name):
			anim_data.frames.append({
				"texture": sprite_frames.get_frame_texture(anim_name, frame_idx),
				"duration": sprite_frames.get_frame_duration(anim_name, frame_idx)
			})
		
		sprite_data.animations[anim_name] = anim_data

# Gerar dados do sprite no formato SGDK
func _generate_sprite_data(image: Image, base_name: String) -> String:
	var result := "const unsigned short %s_data[] = {\n" % base_name
	var width := image.get_width()
	var height := image.get_height()
	
	for y in range(height):
		result += "    "
		for x in range(width):
			var color := image.get_pixel(x, y)
			var color_index := _color_to_md_index(color)
			result += "0x%02X, " % color_index
		
		result += "// Linha %d\n" % y
	
	result += "};\n\n"
	
	result += "const SpriteDefinition %s_def = {\n" % base_name
	result += "    %d, // width\n" % width
	result += "    %d, // height\n" % height
	result += "    %s_data // sprite data\n" % base_name
	result += "};\n\n"
	
	return result

# Gerar dados de animação
func _generate_animation_data(sprite_data: SpriteData, base_name: String) -> String:
	var result := "// Animation data for %s\n" % sprite_data.name
	
	for anim_name in sprite_data.animations:
		var anim_data = sprite_data.animations[anim_name]
		var anim_var_name := "%s_%s" % [base_name, anim_name.to_snake_case()]
		
		result += "const AnimationFrame %s_frames[] = {\n" % anim_var_name
		for frame in anim_data.frames:
			result += "    { 0, %d }, // frame duration\n" % int(frame["duration"] * 60)
		
		result += "};\n\n"
		
		result += "const Animation %s = {\n" % anim_var_name
		result += "    %d, // frame count\n" % anim_data.frames.size()
		result += "    %s_frames, // frames\n" % anim_var_name
		result += "    %s, // loop\n" % ("TRUE" if anim_data.loop else "FALSE")
		result += "    %d // speed\n" % int(anim_data.speed)
		result += "};\n\n"
	
	return result

# Converter correta para índice de paleta
func _color_to_md_index(color: Color) -> int:
	if palette_manager and palette_manager.has_method("color_to_palette_index"):
		return palette_manager.color_to_palette_index(color)
	else:
		# Fallback simples se palette_manager não estiver disponível
		return int(color.r * 15) | (int(color.g * 15) << 4) | (int(color.b * 15) << 8)

# Converter texture para image
func _convert_texture_to_image(texture: Texture2D) -> Image:
	if not texture:
		return null
	
	if texture is ImageTexture:
		return texture.get_image()
	else:
		# Para outros tipos de texture, tentar converter
		var image = texture.get_image()
		if image:
			return image
		else:
			push_error("Failed to convert texture to image: " + texture.resource_path)
			return null

# Salvar arquivo
func _save_to_file(file_path: String, content: String) -> bool:
	var file = FileAccess.open(file_path, FileAccess.WRITE)
	if file:
		file.store_string(content)
		file.close()
		return true
	else:
		push_error("Failed to save file: %s" % file_path)
		return false
