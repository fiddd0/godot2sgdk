@tool
extends RefCounted
class_name AnimationExporter

# Estrutura de dados para animações
class AnimationData:
	var name: String
	var frames: Array = []  # Array de frame indices
	var speed: float = 1.0
	var loop: bool = true
	var frame_durations: Array = []

class SpriteAnimation:
	var sprite_name: String
	var animations: Dictionary = {}  # name: AnimationData
	var frame_textures: Array = []

# Exportar animações da cena
func export_animations_in_scene(scene_root: Node, export_path: String) -> Dictionary:
	var result := {
		"success": false,
		"message": "",
		"exported_files": [],
		"animations_count": 0
	}
	
	if not scene_root:
		result.message = "No scene root found"
		return result
	
	var animated_sprites := _find_animated_sprites(scene_root)
	
	if animated_sprites.is_empty():
		result.message = "No AnimatedSprite2D nodes found"
		return result
	
	# Criar diretório de exportação se não existir
	var dir := DirAccess.open(export_path.get_base_dir())
	if not dir:
		DirAccess.make_dir_recursive_absolute(export_path.get_base_dir())
	
	var header_content := "// Animation data exported from Godot\n// Generated by Godot2SGDK plugin\n\n"
	var animation_count := 0
	
	for sprite_data in animated_sprites:
		var animation_header := _export_animation_data(sprite_data, export_path, animation_count)
		if not animation_header.is_empty():
			header_content += animation_header + "\n"
			result.exported_files.append(sprite_data.sprite_name + "_animations.h")
			result.animations_count += sprite_data.animations.size()
		animation_count += 1
	
	# Salvar arquivo header principal
	var header_file := FileAccess.open(export_path, FileAccess.WRITE)
	if header_file:
		header_file.store_string(header_content)
		header_file.close()
		result.success = true
		result.message = "Export completed: %d animations" % result.animations_count
	else:
		result.message = "Error saving header file: " + export_path
	
	return result

# Encontrar AnimatedSprite2D na cena
func _find_animated_sprites(node: Node) -> Array:
	var sprites := []
	
	if node is AnimatedSprite2D:
		var sprite_data := _extract_animation_data(node)
		if sprite_data:
			sprites.append(sprite_data)
	
	# Buscar recursivamente nos filhos
	for child in node.get_children():
		sprites.append_array(_find_animated_sprites(child))
	
	return sprites

# Extrair dados de animação
func _extract_animation_data(animated_sprite: AnimatedSprite2D) -> SpriteAnimation:
	var sprite_data := SpriteAnimation.new()
	sprite_data.sprite_name = animated_sprite.name
	
	if not animated_sprite.sprite_frames:
		return null
	
	var sprite_frames := animated_sprite.sprite_frames
	
	# Extrair todas as animações
	for anim_name in sprite_frames.get_animation_names():
		var anim_data := AnimationData.new()
		anim_data.name = anim_name
		anim_data.speed = sprite_frames.get_animation_speed(anim_name)
		anim_data.loop = sprite_frames.get_animation_loop(anim_name)
		
		# Extrair frames e durações
		for frame_idx in sprite_frames.get_frame_count(anim_name):
			anim_data.frames.append(frame_idx)
			anim_data.frame_durations.append(sprite_frames.get_frame_duration(anim_name, frame_idx))
		
		sprite_data.animations[anim_name] = anim_data
	
	return sprite_data

# Exportar dados de animação e gerar header
func _export_animation_data(sprite_data: SpriteAnimation, export_path: String, index: int) -> String:
	if sprite_data.animations.is_empty():
		return ""
	
	var base_name := sprite_data.sprite_name.to_snake_case()
	var header_filename := "%s_animations.h" % base_name
	var header_path := export_path.get_base_dir() + "/" + header_filename
	
	var header_content := "// Animations for: %s\n" % sprite_data.sprite_name
	header_content += "// Generated by Godot2SGDK\n\n"
	
	# Gerar dados para cada animação
	for anim_name in sprite_data.animations:
		var anim_data: AnimationData = sprite_data.animations[anim_name]
		header_content += _generate_animation_struct(anim_data, anim_name, base_name)
	
	# Salvar arquivo
	var file := FileAccess.open(header_path, FileAccess.WRITE)
	if file:
		file.store_string(header_content)
		file.close()
		return '#include "%s"\n' % header_filename
	
	return ""

# Gerar estrutura de animação no formato SGDK
func _generate_animation_struct(anim_data: AnimationData, anim_name: String, base_name: String) -> String:
	var var_name := "%s_%s" % [base_name, anim_name.to_snake_case()]
	
	var result := "// Animation: %s\n" % anim_name
	result += "// Frames: %d, Speed: %.1f, Loop: %s\n" % [
		anim_data.frames.size(), anim_data.speed, str(anim_data.loop).to_upper()
	]
	
	# Array de frames
	result += "const u16 %s_frames[] = {\n" % var_name
	result += "    "
	for i in range(anim_data.frames.size()):
		result += "%d" % anim_data.frames[i]
		if i < anim_data.frames.size() - 1:
			result += ", "
			if (i + 1) % 8 == 0:
				result += "\n    "
	result += "\n};\n\n"
	
	# Array de durações (em frames SGDK)
	result += "const u16 %s_durations[] = {\n" % var_name
	result += "    "
	for i in range(anim_data.frame_durations.size()):
		var duration_ms = int(anim_data.frame_durations[i] * 1000)
		var frames_60fps = int(duration_ms / 16.666)  # Converter para frames a 60FPS
		result += "%d" % frames_60fps
		if i < anim_data.frame_durations.size() - 1:
			result += ", "
			if (i + 1) % 8 == 0:
				result += "\n    "
	result += "\n};\n\n"
	
	# Estrutura de animação
	result += "const Animation %s = {\n" % var_name
	result += "    %d,  // frame_count\n" % anim_data.frames.size()
	result += "    %s_frames,  // frames\n" % var_name
	result += "    %s_durations,  // durations\n" % var_name
	result += "    %d,  // speed\n" % int(anim_data.speed * 100)
	result += "    %s  // loop\n" % ("TRUE" if anim_data.loop else "FALSE")
	result += "};\n\n"
	
	return result

# Validar animações para limites do Mega Drive
func validate_animations(animated_sprite: AnimatedSprite2D) -> Array:
	var issues := []
	
	if not animated_sprite.sprite_frames:
		issues.append({"type": "error", "message": "No sprite frames resource"})
		return issues
	
	var sprite_frames := animated_sprite.sprite_frames
	
	for anim_name in sprite_frames.get_animation_names():
		var frame_count = sprite_frames.get_frame_count(anim_name)
		
		# Validar número de frames
		if frame_count > 64:
			issues.append({
				"type": "warning",
				"message": "Animation '%s' has %d frames (recommended max: 64)" % [anim_name, frame_count],
				"node": animated_sprite
			})
		
		# Validar velocidades extremas
		var speed = sprite_frames.get_animation_speed(anim_name)
		if speed > 30:
			issues.append({
				"type": "warning", 
				"message": "Animation '%s' speed is very high: %.1f" % [anim_name, speed],
				"node": animated_sprite
			})
	
	return issues
