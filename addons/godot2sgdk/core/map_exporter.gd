@tool
extends RefCounted
class_name MapExporter

var plugin: Object

func _init(plugin_ref = null):
	plugin = plugin_ref  # ‚úÖ AGORA EST√Å DECLARADA
	print("‚úÖ MapExporter initialized" + (" with plugin" if plugin else ""))

func export_tilemap_data(tilemap: TileMap) -> Dictionary:
	var tilemap_data = {
		"name": tilemap.name,
		"layers": [],
		"size": Vector2i(0, 0),
		"used_cells": 0
	}
	
	for layer in range(tilemap.get_layers_count()):
		var layer_data = _process_tilemap_layer(tilemap, layer)
		tilemap_data["layers"].append(layer_data)
		# ‚úÖ VERIFICA√á√ÉO DE SEGURAN√áA
		if layer_data.has("data") and layer_data["data"] is Array:
			tilemap_data["used_cells"] += layer_data["data"].size()
		else:
			push_warning("Layer data is missing or invalid for layer " + str(layer))
	return tilemap_data

# Suporta ambos: TileMap (Godot 4.3-) e TileMapLayer (Godot 4.4+)
func export_tilemaps_in_scene(scene_root: Node, export_path: String) -> Dictionary:
	print("üéØ [MapExporter] Exporting tilemaps in scene...")
	# ‚úÖ CORRE√á√ÉO: Se n√£o fornecer path, usar das configura√ß√µes
	if export_path.is_empty():
		export_path = _get_export_path() + "tilemaps.h"
	# ... resto do c√≥digo permanece igual ...
	var result := {
		"success": false,
		"message": "",
		"exported_files": []
	}
	
	if not scene_root:
		result.message = "Cena raiz n√£o fornecida"
		return result
	
	var tilemaps := _find_tilemaps_in_node(scene_root)
	
	if tilemaps.is_empty():
		result.message = "Nenhum TileMap ou TileMapLayer encontrado na cena"
		return result
	
	print("üìä [MapExporter] Found %d tilemaps" % tilemaps.size())
	
	# Criar diret√≥rio de exporta√ß√£o se n√£o existir
	var dir := DirAccess.open(export_path.get_base_dir())
	if not dir:
		DirAccess.make_dir_recursive_absolute(export_path.get_base_dir())
	
	var header_content := "// TileMap data exported from Godot\n// Generated by Godot2SGDK plugin\n\n"
	var tilemap_index := 0
	
	for tilemap in tilemaps:
		var tilemap_header := _export_tilemap_data(tilemap, export_path, tilemap_index)
		if not tilemap_header.is_empty():
			header_content += tilemap_header + "\n"
			result.exported_files.append(tilemap.name + "_tilemap.h")
			
		tilemap_index += 1
		var tilemap_data = export_tilemap_data(tilemap)
		var collision_data = export_tilemap_collision(tilemap)  # ‚úÖ NOVO: Exportar colis√£o

		result[tilemap.name] = {
			"tilemap_data": tilemap_data,
			"collision_data": collision_data  # ‚úÖ Adicionar dados de colis√£o
		}
		
		# Gerar headers
		_generate_tilemap_header(tilemap, tilemap_data)
		_generate_tilemap_collision_header(tilemap, collision_data)  # ‚úÖ NOVO: Header de colis√£o
	
	# Salvar arquivo header principal
	var header_file := FileAccess.open(export_path, FileAccess.WRITE)
	if header_file:
		header_file.store_string(header_content)
		header_file.close()
		result.success = true
		result.message = "Exporta√ß√£o conclu√≠da: %d tilemaps exportados" % tilemaps.size()
	else:
		result.message = "Erro ao salvar arquivo header: " + export_path
	
	return result

func export_tilemap_collision(tilemap: TileMap) -> Dictionary:
	var collision_data = {
		"collision_layers": [],
		"collision_shapes": []
	}
	
	if not tilemap.tile_set:
		return collision_data
	
	# Processar camadas de f√≠sica do TileSet
	var physics_layers = _get_physics_layers_data(tilemap.tile_set)
	collision_data["collision_layers"] = physics_layers
	
	# Processar formas de colis√£o dos tiles usados
	var used_tiles = _get_used_tiles(tilemap)
	var collision_shapes = _get_tile_collision_shapes(tilemap.tile_set, used_tiles)
	collision_data["collision_shapes"] = collision_shapes
	
	return collision_data

func _generate_tilemap_collision_header(tilemap: TileMap, collision_data: Dictionary) -> String:
	if collision_data["collision_shapes"].is_empty():
		return ""
	
	var header_content = "// TileMap Collision: %s\n" % tilemap.name
	header_content += "// Generated by Godot2SGDK\n\n"
	
	# Exportar layers de colis√£o
	for layer in collision_data["collision_layers"]:
		header_content += "#define TILEMAP_%s_PHYSICS_LAYER_%d 0x%X\n" % [
			tilemap.name.to_upper(), layer["layer_id"], layer["collision_layer"]
		]
	
	header_content += "\n"
	
	# Exportar formas de colis√£o (implementa√ß√£o simplificada)
	header_content += "// Collision shapes for %s\n" % tilemap.name
	header_content += "// Note: Implement collision handling based on tile types\n"
	
	var file_path = "res://export/%s_collision.h" % tilemap.name.to_lower()
	_save_to_file(file_path, header_content)
	
	return header_content

func _generate_tilemap_header(tilemap: TileMap, tilemap_data: Dictionary) -> String:
	var header_content = "// TileMap: %s\n" % tilemap_data.get("name", "Unknown")
	header_content += "// Type: %s\n" % tilemap.get_class()
	header_content += "// Size: %dx%d\n" % [tilemap_data.get("size", Vector2i.ZERO).x, tilemap_data.get("size", Vector2i.ZERO).y]
	header_content += "// Layers: %d\n\n" % tilemap_data.get("layers", []).size()
	
	for layer_idx in range(tilemap_data.get("layers", []).size()):
		var layer = tilemap_data["layers"][layer_idx]
		var layer_name = layer.get("name", "Layer_%d" % layer_idx)
		header_content += "// Layer: %s\n" % layer_name
		header_content += "// Visible: %s\n" % ("TRUE" if layer.get("visible", true) else "FALSE")
		header_content += "// Cells: %d\n" % layer.get("data", []).size()
		header_content += "const unsigned short %s_layer_%d[] = {\n" % [tilemap.name.to_lower(), layer_idx]
		
		# Adicionar dados dos tiles
		var layer_data = layer.get("data", [])
		for i in range(layer_data.size()):
			if i % 16 == 0:
				header_content += "    "
			header_content += "0x%04X, " % layer_data[i].get("packed_data", 0)
			if i % 16 == 15 or i == layer_data.size() - 1:
				header_content += "\n"
		
		header_content += "};\n\n"
		
		# Adicionar struct da layer
		header_content += "const TileLayer %s_layer_%d_layer = {\n" % [tilemap.name.to_lower(), layer_idx]
		header_content += "    %d,  // cell_count\n" % layer_data.size()
		header_content += "    %s_layer_%d,  // cells\n" % [tilemap.name.to_lower(), layer_idx]
		header_content += "    %s  // visible\n" % ("TRUE" if layer.get("visible", true) else "FALSE")
		header_content += "};\n\n"
	
	var file_path = "res://export/%s_tilemap.h" % tilemap.name.to_lower()
	_save_to_file(file_path, header_content)
	
	return header_content

func _get_atlas_coords_alternative(tilemap_node, layer_idx: int, cell: Vector2i, source_id: int) -> Vector2i:
	if source_id == -1:
		return Vector2i.ZERO
	
	var tile_set = null
	if tilemap_node is TileMap:
		tile_set = tilemap_node.tile_set
	elif tilemap_node is TileMapLayer:
		tile_set = tilemap_node.tile_set
	
	if tile_set:
		for atlas_source_id in tile_set.get_source_count():
			var source = tile_set.get_source(atlas_source_id)
			if source and source.get_id() == source_id:
				return Vector2i(source_id % 16, source_id / 16)
	
	return Vector2i(cell.x % 16, cell.y % 16)

func _get_physics_layers_data(tile_set: TileSet) -> Array:
	var layers_data = []
	return layers_data

func _get_used_tiles(tilemap: TileMap) -> Array:
	var used_tiles = []
	return used_tiles

func _get_tile_collision_shapes(tile_set: TileSet, used_tiles: Array) -> Array:
	var shapes_data = []
	return shapes_data

func _get_shape_type(shape: Shape2D) -> String:
	if shape is RectangleShape2D:
		return "rectangle"
	elif shape is CircleShape2D:
		return "circle"
	elif shape is CapsuleShape2D:
		return "capsule"
	elif shape is ConvexPolygonShape2D:
		return "convex_polygon"
	elif shape is ConcavePolygonShape2D:
		return "concave_polygon"
	return "unknown"

func _get_shape_data(shape: Shape2D) -> Dictionary:
	var data = {}
	return data

func _find_tilemaps_in_node(node: Node) -> Array:
	var tilemaps := []
	
	if node is TileMap or node is TileMapLayer:
		tilemaps.append(node)
		print("üìç Found TileMap: ", node.name, " (Type: ", node.get_class(), ")")
	
	for child in node.get_children():
		tilemaps.append_array(_find_tilemaps_in_node(child))
	
	return tilemaps

func _process_tilemap(tilemap_node: Node) -> Dictionary:
	var result := {
		"layers": [],
		"size": Vector2i.ZERO,
		"name": tilemap_node.name,
		"type": tilemap_node.get_class()
	}
	
	if tilemap_node is TileMap:
		var used_rect = tilemap_node.get_used_rect()
		if used_rect != Rect2i():
			result["size"] = used_rect.size
		
		for layer_idx in tilemap_node.get_layers_count():
			var layer_data = _process_tilemap_layer(tilemap_node, layer_idx)
			result["layers"].append(layer_data)
			
	elif tilemap_node is TileMapLayer:
		var used_rect = tilemap_node.get_used_rect()
		if used_rect != Rect2i():
			result["size"] = used_rect.size
		
		var layer_data = _process_tilemap_layer(tilemap_node, 0)
		result["layers"].append(layer_data)
	
	print("üõ†Ô∏è Processing tilemap: ", tilemap_node.name, " (Layers: ", result["layers"].size(), ")")
	return result

func _process_tilemap_layer(tilemap_node: Node, layer_idx: int) -> Dictionary:
	var layer_data := {
		"name": "Layer_%d" % layer_idx,
		"data": [],
		"visible": true
	}
	
	var used_cells = []
	if tilemap_node is TileMap:
		used_cells = tilemap_node.get_used_cells(layer_idx)
		layer_data["visible"] = tilemap_node.is_layer_enabled(layer_idx)
	elif tilemap_node is TileMapLayer:
		used_cells = tilemap_node.get_used_cells()
		layer_data["visible"] = tilemap_node.visible
		layer_data["name"] = tilemap_node.name if tilemap_node.name != "" else "Layer_%d" % layer_idx
	
	for cell in used_cells:
		var tile_id = 0
		var atlas_coords = Vector2i.ZERO
		var alternative_id = 0
		var source_id = 0
		
		var tile_data = null
		if tilemap_node is TileMap:
			tile_data = tilemap_node.get_cell_tile_data(layer_idx, cell)
			source_id = tilemap_node.get_cell_source_id(layer_idx, cell)
		elif tilemap_node is TileMapLayer:
			tile_data = tilemap_node.get_cell_tile_data(cell)
			source_id = tilemap_node.get_cell_source_id(cell)

		if tile_data:
			# ‚úÖ CORRE√á√ÉO PARA Godot 4.4.1 - usar m√©todos dispon√≠veis
			if tile_data.has_method("get_atlas_coords"):
				atlas_coords = tile_data.get_atlas_coords()
			elif tilemap_node is TileMap:
				atlas_coords = tilemap_node.get_cell_atlas_coords(layer_idx, cell)
			elif tilemap_node is TileMapLayer:
				atlas_coords = tilemap_node.get_cell_atlas_coords(cell)
			
			if tile_data.has_method("get_alternative_tile"):
				alternative_id = tile_data.get_alternative_tile()
			else:
				alternative_id = 0
			
			tile_id = source_id
		else:
			continue
		
		var packed_data = (tile_id << 12) | (atlas_coords.y << 6) | atlas_coords.x
		if alternative_id > 0:
			packed_data |= (alternative_id << 8)
		
		layer_data["data"].append({
			"cell": cell,
			"packed_data": packed_data,
			"tile_id": tile_id,
			"atlas_coords": atlas_coords,
			"alternative_id": alternative_id
		})
	
	return layer_data

func _export_tilemap_data(tilemap_node: Node, export_path: String, index: int) -> String:
	var tilemap_data = _process_tilemap(tilemap_node)
	
	if tilemap_data["layers"].is_empty():
		return ""
	
	var base_name = tilemap_node.name.to_snake_case()
	var header_filename = "%s_tilemap.h" % base_name
	var header_path = export_path.get_base_dir() + "/" + header_filename
	
	var header_content = "// TileMap: %s\n" % tilemap_node.name
	header_content += "// Type: %s\n" % tilemap_data["type"]
	header_content += "// Size: %dx%d\n" % [tilemap_data["size"].x, tilemap_data["size"].y]
	header_content += "// Layers: %d\n\n" % tilemap_data["layers"].size()
	
	for layer_idx in range(tilemap_data["layers"].size()):
		var layer = tilemap_data["layers"][layer_idx]
		header_content += _generate_layer_data(layer, base_name, layer_idx)
	
	var file = FileAccess.open(header_path, FileAccess.WRITE)
	if file:
		file.store_string(header_content)
		file.close()
		return '#include "%s"\n' % header_filename
	
	return ""

func _generate_layer_data(layer_data: Dictionary, base_name: String, layer_idx: int) -> String:
	var layer_name = layer_data.get("name", "Layer_%d" % layer_idx).to_snake_case()
	var var_name = "%s_%s" % [base_name, layer_name]
	
	var result = "// Layer: %s\n" % layer_data.get("name", "Layer_%d" % layer_idx)
	result += "// Visible: %s\n" % ("true" if layer_data.get("visible", true) else "false")
	result += "// Cells: %d\n" % layer_data.get("data", []).size()
	
	result += "const unsigned short %s[] = {\n" % var_name
	result += "    "
	
	var cells = layer_data.get("data", [])
	for i in range(cells.size()):
		result += "0x%04X" % cells[i].get("packed_data", 0)
		
		if i < cells.size() - 1:
			result += ", "
			if (i + 1) % 8 == 0:
				result += "\n    "
	
	result += "\n};\n\n"
	
	result += "const TileLayer %s_layer = {\n" % var_name
	result += "    %d,  // cell_count\n" % cells.size()
	result += "    %s,  // cells\n" % var_name
	result += "    %s  // visible\n" % ("TRUE" if layer_data.get("visible", true) else "FALSE")
	result += "};\n\n"
	
	return result

func export_scene_manually(scene_root: Node) -> void:
	print("üöÄ [MapExporter] Starting MANUAL export...")
	
	# ‚úÖ CORRE√á√ÉO: Usar path das configura√ß√µes
	var export_path = _get_export_path() + "tilemaps.h"
	var result = export_tilemaps_in_scene(scene_root, export_path)
	
	if result.success:
		print("‚úÖ [MapExporter] Manual export completed!")
		print("üìÅ Files: ", result.exported_files)
	else:
		print("‚ùå [MapExporter] Export failed: ", result.message)

# ‚úÖ FUN√á√ÉO AUXILIAR NOVA (adicionar esta tamb√©m)
func _get_export_path() -> String:
	# ‚úÖ CORRE√á√ÉO: Verificar se plugin existe e tem o m√©todo
	if plugin != null and plugin.has_method("get_export_path"):
		var path = plugin.get_export_path()
		# Garantir que termina com /
		if not path.ends_with("/"):
			path += "/"
		return path
	
	# Fallback para padr√£o
	return "res://export/"

func _save_to_file(file_path: String, content: String) -> bool:
	var file = FileAccess.open(file_path, FileAccess.WRITE)
	if file:
		file.store_string(content)
		file.close()
		return true
	else:
		push_error("Failed to save file: %s" % file_path)
		return false
